; Arithmetic Operators
(def + (fn [] 0))
(def + (fn [a] a))
(def + (fn [a b] (add a b)))
(def + (fn [a b & rest] (apply + (+ a b) rest)))

(def - (fn [] 0))
(def - (fn [a] (* a -1)))
(def - (fn [a b] (subtract a b)))
(def - (fn [a b & rest] (apply - (- a b) rest)))

(def * (fn [] 1))
(def * (fn [a] a))
(def * (fn [a b] (multiply a b)))
(def * (fn [a b & rest] (apply * (* a b) rest)))

(def / (fn [a] a))
(def / (fn [a b] (divide a b)))
(def / (fn [a b & rest] (apply / (/ a b) rest)))

; Comparison Operators
(def = eq?)
(def > gt?)
(def < lt?)
(def gt_or_eq? (fn [a b] (or (> a b) (= a b))))
(def lt_or_eq? (fn [a b] (or (< a b) (= a b))))
(def >= gt_or_eq?)
(def <= lt_or_eq?)

; Constructor Operators
(def : cons)

(def map (fn [f coll]
  (let [h (f (head coll))
        t (tail coll)]
          (: h (if (empty? t) t (map f t))))))


(def foldl (fn [f a] a))
(def foldl (fn [f a b] (f a b)))
(def foldl (fn [f a b & rest] (apply foldl f (f a b) rest)))

; Is this impl correct?
(def foldr (fn [f acc coll] 
  (let [x (f (head coll) acc)
        xs (tail coll)]
    (if (empty? xs) 
      x 
      (foldl f x xs)))))

; I just defined this simply because I wanted
; a function to play with :) 
(def double (fn [i] (+ i i)))
